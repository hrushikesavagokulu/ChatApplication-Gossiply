
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chat</title>
  <link rel="stylesheet" href="/public/css/home.css" />
  <script src="/socket.io/socket.io.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.0/css/all.min.css"
/>
  <style>
  :root {
  --primary: #007bff;
  --secondary: #f6ec5e;
  --bg-light: #f4f7f9;
  --bg-dark: #121212;
  --text-light: #eee;
  --text-dark: #222;
  --card-light: #fff;
  --card-dark: #1f1f1f;
  --hover-bg: #f0f0f0;
}

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  width: 100%;
  height:90%;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #88649e;
  color: var(--text-dark);
  transition: all 0.3s ease;
}

body.dark-mode {
  background-color: var(--bg-dark);
  color: var(--text-light);
}

nav {
  display: flex;
  align-items: center;
  padding: 0.8rem 1.5rem;
  margin: 8px;
  border-radius: 6px;
  background-color: #875b1a;
  border-bottom: 1px solid #ccc;
  gap: 1rem;
  position: sticky;
  top: 0;
  z-index: 1000;
}
nav {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.nav-left {
  flex: 1;
}

.nav-right {
  display: flex;
  gap: 1rem;
  align-items: center;
}

body.dark-mode nav {
  background-color: var(--card-dark);
  border-color: #444;
}

nav a,
nav button {
  color: #f5f2f2;
  text-decoration: none;
  font-weight: 500;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 1rem;
  padding: 6px 12px;
  border-radius: 6px;
  transition: background 0.2s;
}

nav a:hover,
nav button:hover {
  background-color: #442605;
}

body.dark-mode nav a,
body.dark-mode nav button {
  color: var(--text-light);
}

body.dark-mode nav a:hover,
body.dark-mode nav button:hover {
  background-color: #2a2a2a;
}

.container {
  display: flex;
  width: 100%;
  height: calc(100vh - 60px);
  height:96%;
}

.contacts {
  width: 30%;
  max-height: calc(100vh - 60px);
  background-color: #899c99;
  border-right: 1px solid #ccc;
  overflow-y: auto;
  padding: 1rem;
  margin-left: 8%;
  margin-top: 10px;
  margin-right: 2%;
  border-radius: 10px 0 0 10px;
  box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
  scrollbar-width: thin;
  scrollbar-color: #bbb transparent;
  
}

.contacts::-webkit-scrollbar {
  width: 6px;
}

.contacts::-webkit-scrollbar-thumb {
  background-color: #bbb;
  border-radius: 6px;
}

body.dark-mode .contacts {
  background-color: var(--card-dark);
  border-color: #444;
}

.contacts h2 {
  margin-bottom: 1rem;
  font-size: 1.2rem;
  color: var(--primary);
  border-bottom: 1px solid #ddd;
  padding-bottom: 5px;
}

.contacts ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.contact {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 8px;
  margin-bottom: 6px;
  border-radius: 8px;
  background-color: #e1ca9b;
  transition: background 0.2s, transform 0.1s;
}

.contact:hover {
  background-color: #eaeaea;
  transform: translateY(-1px);
}

body.dark-mode .contact {
  background-color: #2a2a2a;
}

body.dark-mode .contact:hover {
  background-color: #3a3a3a;
}

.contact.unread strong {
  color: var(--secondary);
  font-weight: bold;
}

.unread-dot {
  width: 8px;
  height: 8px;
  background: var(--secondary);
  border-radius: 50%;
  margin-left: 5px;
  display: inline-block;
}

.contact img {
  border-radius: 50%;
  margin-right: 10px;
  width: 40px;
  height: 40px;
  object-fit: cover;
}

.contact strong {
  flex-grow: 1;
  margin-left: 10px;
}

.chat-room {
  flex: 1;
  display: flex;
  width:60%;
  
  flex-direction: column;
  background-color: var(--bg-light);
  padding: 1rem;
}

body.dark-mode .chat-room {
  background-color: #181818;
}

.messages {
  flex: 1;
  overflow-y: auto;
  background: #4a4953;
  padding: 1rem;
  border-radius: 8px;
  font-size: small;
}

body.dark-mode .messages {
  background-color: #272727;
}

.message {
  display: flex;
  align-items: flex-end;
  margin-bottom: 12px;
}

.message.me {
  flex-direction: row-reverse;
  text-align: right;
}

.message-content {
  max-width: 65%;
  padding: 10px 14px;
  border-radius: 16px;
  background: var(--primary);
  color: #000000;
  word-wrap: break-word;
  white-space: pre-wrap;
}

.message.me .message-content {
  background: var(--secondary);
}

.message-time {
  font-size: 0.7rem;
  color: #fdfafa;
  margin-top: 4px;
}

.chat-input {
  display: flex;
  gap: 10px;
  padding-top: 10px;
  border-top: 1px solid #c11313;
}

textarea {
  flex: 1;
  padding: 10px;
  border-radius: 8px;
  border: 1px solid #ccc;
  font-size: 1rem;
  resize: none;
}

button {
  padding: 10px 16px;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  cursor: pointer;
}

#uploadBtn {
  background-color: var(--primary);
  color: white;
}

#sendBtn {
  background-color: var(--secondary);
  color: black;
}

#sendBtn:disabled {
  background-color: #aaa;
  cursor: not-allowed;
}

#emojiBtn {
  background-color: #ffc107;
  color: #333;
}

.view-profile-btn {
  padding: 6px 10px;
  font-size: 0.75rem;
  background-color: var(--primary);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}

.view-profile-btn:hover {
  background-color: #0056b3;
}

    .emoji-animation {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin: 30px auto 10px;
  animation: floatEmojis 2s ease-in-out infinite;
  font-size: 2.2rem;
}


emoji-picker {
  position: absolute;
  bottom: 60px;
  right: 60px;
  z-index: 999;
  display: none;
}

@media (max-width: 768px) {
  .container {
    flex-direction: column;
  }

  .contacts {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid #706f6f;
    border-radius: 0;
  }

  .chat-input {
    flex-direction: column;
    align-items: stretch;
  }

  #sendBtn,
  #uploadBtn {
    width: 100%;
  }
}

/* Chat Placeholder View with Emoji Background */
.chat-room {
  position: relative;
  flex: 1;
  display: flex;
  flex-direction: column;
  background-color: #874258;
  padding: 1rem;
  overflow: hidden;
}

body.dark-mode .chat-room {
  background: linear-gradient(to top left, #0a0a0a, #131313, #1f1f1f, #111111, #0a0a0a);
}



.chat-placeholder {
  z-index: 2;
  margin: auto;
  text-align: center;
  color: #f1f5f9;
  background: rgba(44, 46, 49, 0.6);
  padding: 30px 40px;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

.chat-placeholder h2 {
  font-size: 2rem;
  margin-bottom: 12px;
}

.chat-placeholder p {
  font-size: 1rem;
  color: #cbd5e1;
}

/* Emoji Floating Animation Background */
.emoji-float-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  z-index: 1;
  pointer-events: none;
}

.emoji-float {
  position: absolute;
  top: 100vh;
  opacity: 0.75;
  pointer-events: none;
  animation-name: emojiUp;
  animation-timing-function: linear;
  animation-iteration-count: infinite;
  z-index: 1;
}

@keyframes emojiUp {
  0% {
    transform: translateY(0);
    opacity: 0;
  }
  30% {
    opacity: 1;
  }
  100% {
    transform: translateY(-120vh);
    opacity: 0;
  }
}

.unread-count {
  background: crimson;
  color: white;
  font-size: 0.75rem;
  padding: 2px 6px;
  border-radius: 12px;
  margin-left: 8px;
}


@media (max-width: 768px) {
  body {
    font-size: 18px;
  }

  .container {
    flex-direction: column;
    height: auto;
  }

  .contacts {
    width: 100%;
    padding: 1.5rem;
    border-radius: 0;
    border-bottom: 2px solid #555;
    font-size: 1.1rem;
  }

  .contact {
    padding: 16px;
    gap: 10px;
  }

  .contact img {
    width: 80px !important;
    height: 80px !important;
  }

  .contact strong {
    font-size: 1.4rem;
  }

  .chat-room {
    width: 100%;
    padding: 1.5rem;
  }

  .chat-header img {
    width: 70px !important;
    height: 70px !important;
  }

  .chat-header h2 {
    font-size: 1.8rem;
  }

  .messages {
    font-size: 1.4rem;
    padding: 1.4rem;
    min-height: 300px;
    max-height: 400px;
  }

  .message-content {
    font-size: 1.4rem !important;
    padding: 16px 20px;
    border-radius: 24px;
    line-height: 1.6;
  }

  .message-time {
    font-size: 1.1rem;
  }

  .chat-input {
    flex-direction: column;
    gap: 14px;
  }

  textarea {
    font-size: 1.3rem;
    padding: 14px;
  }

  #sendBtn,
  #uploadBtn,
  #emojiBtn {
    width: 100%;
    font-size: 1.3rem;
    padding: 14px;
  }

  .view-profile-btn {
    font-size: 1.2rem;
    padding: 12px;
  }

  .unread-count {
    font-size: 1.2rem;
    padding: 6px 10px;
  }

  .nav-right a,
  .nav-right button {
    font-size: 1.4rem;
    padding: 12px;
  }

  nav {
    flex-wrap: wrap;
    gap: 1rem;
  }

  emoji-picker {
    width: 100vw !important;
    height: 360px !important;
    bottom: 80px !important;
    right: 10px !important;
  }
}


</style>

</head>

<body>
  
<h1 style="display: none;">Home</h1>
<nav>
  <!-- LEFT SIDE: Logo -->
  <div class="nav-left">
    <a href="/" aria-label="Gossiply Home">
      <i class="fa-solid fa-comments"></i> <strong style="font-size: 1.2rem;">Gossiply</strong>
    </a>
  </div>

  <!-- RIGHT SIDE: Links -->
  <div class="nav-right">
    <a href="/home" aria-label="Home">
      <i class="fa-solid fa-house"></i> Home
    </a>

    <a href="/profile" aria-label="Profile">
      <i class="fa-solid fa-user"></i> Profile
    </a>

    <a href="/search" aria-label="Search">
      <i class="fa-solid fa-magnifying-glass"></i> Search
    </a>

    <button id="darkModeToggle" aria-label="Toggle Dark Mode">
      <i class="fa-solid fa-moon"></i> <span id="modeLabel">Dark Mode</span>
    </button>

    <a href="/logout" aria-label="Logout">
      <i class="fa-solid fa-right-from-bracket"></i> Logout
    </a>
  </div>
</nav>


  <div class="container">
  <div class="contacts">

    <!-- ‚úÖ Friend Requests Section (Static) -->
    <div class="requests-section">
      <% if (requests.length > 0) { %>
        <h2>Friend Requests</h2>
        <ul>
          <% requests.forEach(request => { %>
            <li>
              <img src="<%= request.avatar || '/images/default-avatar.png' %>" width="30" />
              <%= request.username %>
              <form action="/accept-request/<%= request._id %>" method="POST" style="display:inline;">
                <button type="submit">Accept</button>
              </form>
              <form action="/reject-request/<%= request._id %>" method="POST" style="display:inline;">
                <button type="submit">Reject</button>
              </form>
            </li>
          <% }) %>
        </ul>
      <% } else { %>
        <p style="color: #006127;">No friend requests</p>
      <% } %>
    </div>

    <!-- ‚úÖ Contacts Section (Dynamic Refresh) -->
    <div class="contacts-section">
  <div id="new-messages-list">
    <% if (newMsgContacts.length > 0) { %>
      <h2>New Messages</h2>
      <ul>
        <% newMsgContacts.forEach(contact => { %>
          <li class="contact unread"
              data-id="<%= contact._id %>"
              data-username="<%= contact.username %>"
              data-avatar="<%= contact.avatar || '/images/default-avatar.png' %>">
            <img src="<%= contact.avatar || '/images/default-avatar.png' %>" width="40" height="40" />
            <strong>
              <%= contact.username %>
              <span class="unread-count">(<%= unreadCounts[contact._id.toString()] %>)</span>
            </strong>
            <button class="view-profile-btn" data-userid="<%= contact._id %>">View Profile</button>
          </li>
        <% }) %>
      </ul>
    <% } %>
  </div>

  <div id="normal-contacts-list">
    <% if (normalContacts.length > 0) { %>
      <h2>Contacts</h2>
      <ul>
        <% normalContacts.forEach(contact => { %>
          <li class="contact"
              data-id="<%= contact._id %>"
              data-username="<%= contact.username %>"
              data-avatar="<%= contact.avatar || '/images/default-avatar.png' %>">
            <img src="<%= contact.avatar || '/images/default-avatar.png' %>" width="40" height="40" />
            <strong><%= contact.username %></strong>
            <button class="view-profile-btn" data-userid="<%= contact._id %>">View Profile</button>
          </li>
        <% }) %>
      </ul>
    <% } %>
  </div>
</div>


  </div>

    <div class="chat-room" id="chat-room">
  <div class="emoji-float-bg"></div>
  <div class="chat-placeholder">
    <h2>üí¨ Start a Chat</h2>
    <p>Select a contact to begin chatting...</p>
  </div>
</div>


  </div>

  <script>
  const toggleBtn = document.getElementById('darkModeToggle');
  const body = document.body;

  const emojis = [
    'üí¨', 'üòÑ', 'üòÇ', 'üòâ', 'üòä', 'üòé', 'üôå', 'ü•≥', 'ü§©', 'üéâ',
    'üëç', 'üôà', 'üòú', 'üòá', 'üòª', 'üåà', '‚ú®', 'üåü', 'üí•', 'üî•',
    'üíñ', 'üí´', 'üòà', 'üëÄ', 'üí≠', 'üôÉ', 'üòÖ', 'üòÜ', 'üåÄ', 'üîÜ'
  ];

  const emojiContainer = document.querySelector('.emoji-float-bg');
  for (let i = 0; i < 35; i++) {
    const emoji = document.createElement('div');
    emoji.classList.add('emoji-float');
    emoji.innerText = emojis[Math.floor(Math.random() * emojis.length)];
    emoji.style.left = Math.random() * 100 + 'vw';
    emoji.style.animationDuration = (4 + Math.random() * 3).toFixed(2) + 's';
    emoji.style.animationDelay = (Math.random() * 5).toFixed(2) + 's';
    emoji.style.fontSize = (1.2 + Math.random() * 1.5).toFixed(2) + 'rem';
    emojiContainer.appendChild(emoji);
  }

  if (localStorage.getItem('darkMode') === 'enabled') {
    body.classList.add('dark-mode');
    toggleBtn.textContent = '‚òÄ Light Mode';
  }

  toggleBtn.addEventListener('click', () => {
    body.classList.toggle('dark-mode');
    if (body.classList.contains('dark-mode')) {
      localStorage.setItem('darkMode', 'enabled');
      toggleBtn.textContent = '‚òÄ Light Mode';
    } else {
      localStorage.setItem('darkMode', 'disabled');
      toggleBtn.textContent = 'üåô Dark Mode';
    }
  });

  document.addEventListener('DOMContentLoaded', () => {
    const socket = io();

    const currentUserId = "<%= user._id %>";
    const currentUserAvatar = "<%= user.avatar || '/images/default-avatar.png' %>";

    let currentConversationId = null;
    let currentFriendId = null;

    const chatRoom = document.getElementById('chat-room');
    const contacts = document.querySelectorAll('.contact');
    const conversationToFriendMap = {};

    function scrollMessagesToBottom() {
      const messagesDiv = document.getElementById('messages');
      if (messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function insertAtCursor(input, textToInsert) {
      const start = input.selectionStart;
      const end = input.selectionEnd;
      input.value = input.value.slice(0, start) + textToInsert + input.value.slice(end);
      input.selectionStart = input.selectionEnd = start + textToInsert.length;
    }

    function setupEmojiPickerHandlers() {
      const emojiPicker = document.getElementById('emojiPicker');
      const emojiBtn = document.getElementById('emojiBtn');
      const input = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      if (!emojiPicker || !emojiBtn || !input || !sendBtn) return;

      emojiBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        emojiPicker.style.display = emojiPicker.style.display === 'block' ? 'none' : 'block';
      });

      emojiPicker.addEventListener('emoji-click', event => {
        const emoji = event.detail.unicode;
        insertAtCursor(input, emoji);
        sendBtn.disabled = !input.value.trim();
        setTimeout(() => input.focus(), 10);
      });

      document.addEventListener('click', (event) => {
        if (!emojiPicker.contains(event.target) && event.target !== emojiBtn) {
          emojiPicker.style.display = 'none';
        }
      });
      
    }

document.querySelector('.contacts').addEventListener('click', async (e) => {
  const contact = e.target.closest('.contact');
  if (!contact || e.target.classList.contains('view-profile-btn')) return;

  const selectedFriendId = contact.dataset.id;
  const friendUsername = contact.dataset.username;
  const friendAvatar = contact.dataset.avatar;

  if (selectedFriendId === currentFriendId) return; // Skip reloading same contact

  currentFriendId = selectedFriendId;
  contact.classList.remove('unread');

  try {
    const res = await fetch(`/chat/conversation/${currentFriendId}`);
    const conversation = res.ok ? await res.json() : { messages: [], _id: null };

    currentConversationId = conversation._id ? String(conversation._id) : null;

    if (currentConversationId) {
      conversationToFriendMap[currentConversationId] = currentFriendId;

      socket.emit('joinRoom', {
        conversationId: currentConversationId,
        userId: currentUserId,
        friendId: currentFriendId
      });

      socket.emit('markAsRead', {
        conversationId: currentConversationId,
        userId: currentUserId
      });
    }

    renderChat(conversation, friendUsername, friendAvatar);
  } catch (err) {
    console.error('Failed to fetch conversation:', err);
    renderChat({ messages: [], _id: null }, friendUsername, friendAvatar);
  }
});


    function renderChat(conversation, friendName, friendAvatar) {
      chatRoom.innerHTML = `
        <div class="chat-header" style="display:flex; align-items:center; gap:10px; margin-bottom:1rem;">
          <img src="${friendAvatar}" width="40" style="border-radius:50%;" alt="Friend Avatar" />
          <h2>Chat with ${friendName}</h2>
        </div>
        <div class="messages" id="messages"></div>
        <div class="chat-input" style="position: relative;">
          <textarea id="messageInput" rows="2" placeholder="Type a message..."></textarea>
          <button id="emojiBtn" type="button" title="Emoji picker">&#128515;</button>
          <emoji-picker 
            id="emojiPicker" 
            style="position: fixed; bottom: 60px; right: 60px; display: none; z-index: 9999; width: 320px; height: 300px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); border-radius: 8px; background: white;">
          </emoji-picker>
          <input type="file" id="fileInput" style="display:none" />
          <label for="fileInput" id="uploadBtn" title="Upload file" style="cursor: pointer;">üìé</label>
          <button id="sendBtn" disabled>Send</button>
        </div>
      `;

      const messagesDiv = document.getElementById('messages');
      const input = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');

      messagesDiv.innerHTML = '';
      conversation.messages.forEach(addMessage);
      scrollMessagesToBottom();

      input.addEventListener('input', () => {
        sendBtn.disabled = !input.value.trim();
      });

      sendBtn.onclick = () => {
        const text = input.value.trim();
        if (!text) return;

        const localMessage = {
          senderId: currentUserId,
          text,
          timestamp: new Date().toISOString()
        };
        addMessage(localMessage);
        scrollMessagesToBottom();

        socket.emit('chatMessage', {
          conversationId: currentConversationId,
          senderId: currentUserId,
          text
        });

        input.value = '';
        sendBtn.disabled = true;
      };

      setupEmojiPickerHandlers();

      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');

      uploadBtn.addEventListener('click', () => {
        fileInput.click();
      });

      fileInput.addEventListener('change', () => {
        const file = fileInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = () => {
          socket.emit('chatFile', {
            conversationId: currentConversationId,
            senderId: currentUserId,
            fileName: file.name,
            fileType: file.type,
            fileData: reader.result
          });

          addMessage({
            senderId: currentUserId,
            text: `[File] ${file.name}`,
            timestamp: new Date().toISOString()
          });
          scrollMessagesToBottom();
        };
        reader.readAsDataURL(file);
        fileInput.value = '';
      });
    }

    socket.on('newMessage', (msg) => {
      const convIdStr = String(msg.conversationId);
      const currentConvStr = String(currentConversationId);

      if (convIdStr === currentConvStr) {
        if (msg.senderId !== currentUserId) {
          addMessage(msg);
          scrollMessagesToBottom();
        }
      } else if (msg.senderId !== currentUserId) {
        const friendId = conversationToFriendMap[convIdStr];
        const contactEl = document.querySelector(`.contact[data-id="${friendId}"]`);
        if (contactEl) {
          contactEl.classList.add('unread');
          const contactsList = contactEl.parentElement;
          if (contactsList) contactsList.prepend(contactEl);
        }
      }
    });

    function addMessage(message) {
      const messagesDiv = document.getElementById('messages');
      if (!messagesDiv) return;

      const isMe = message.sender?._id === currentUserId || message.senderId === currentUserId;
      const avatar = isMe
        ? currentUserAvatar
        : (document.querySelector(`.contact[data-id="${currentFriendId}"]`)?.dataset.avatar || '/images/default-avatar.png');

      const time = new Date(message.timestamp || Date.now()).toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });

      const msgDiv = document.createElement('div');
      msgDiv.classList.add('message', isMe ? 'me' : 'friend');
      msgDiv.innerHTML = `
        <img src="${avatar}" class="message-avatar" alt="Avatar" />
        <div>
          <div class="message-content">${escapeHtml(message.text)}</div>
          <div class="message-time">${time}</div>
        </div>
      `;
      messagesDiv.appendChild(msgDiv);
    }

    
document.addEventListener('click', (e) => {
  const btn = e.target.closest('.view-profile-btn');
  if (btn) {
    e.stopPropagation();
    const userId = btn.dataset.userid;
    window.location.href = `/user/${userId}`;
  }
});


    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  });

setInterval(async () => {
  try {
    const res = await fetch('/api/contacts');
    const data = await res.json();

    if (data.success) {
      const newMessagesList = document.getElementById('new-messages-list');
      const normalContactsList = document.getElementById('normal-contacts-list');

      newMessagesList.innerHTML = '';
      normalContactsList.innerHTML = '';

      const newMsgContacts = data.contacts.filter(c => c.unreadCount > 0);
      const normalContacts = data.contacts.filter(c => c.unreadCount === 0);

      if (newMsgContacts.length > 0) {
        const h2 = document.createElement('h2');
        h2.textContent = 'New Messages';
        const ul = document.createElement('ul');

        newMsgContacts.forEach(contact => {
          const li = document.createElement('li');
          li.className = 'contact unread';
          li.dataset.id = contact._id;
          li.dataset.username = contact.username;
          li.dataset.avatar = contact.avatar || '/images/default-avatar.png';

          li.innerHTML = `
            <img src="${contact.avatar || '/images/default-avatar.png'}" width="40" height="40" />
            <strong>${contact.username} <span class="unread-count">(${contact.unreadCount})</span></strong>
            <button class="view-profile-btn" data-userid="${contact._id}">View Profile</button>
          `;
          ul.appendChild(li);
        });

        newMessagesList.appendChild(h2);
        newMessagesList.appendChild(ul);
      }

      if (normalContacts.length > 0) {
        const h2 = document.createElement('h2');
        h2.textContent = 'Contacts';
        const ul = document.createElement('ul');

        normalContacts.forEach(contact => {
          const li = document.createElement('li');
          li.className = 'contact';
          li.dataset.id = contact._id;
          li.dataset.username = contact.username;
          li.dataset.avatar = contact.avatar || '/images/default-avatar.png';

          li.innerHTML = `
            <img src="${contact.avatar || '/images/default-avatar.png'}" width="40" height="40" />
            <strong>${contact.username}</strong>
            <button class="view-profile-btn" data-userid="${contact._id}">View Profile</button>
          `;
          ul.appendChild(li);
        });

        normalContactsList.appendChild(h2);
        normalContactsList.appendChild(ul);
      }

      document.querySelectorAll('.view-profile-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const userId = btn.dataset.userid;
          window.location.href = `/user/${userId}`;
        });
      });
    }
  } catch (err) {
    console.error('Failed to refresh contacts:', err);
  }
}, 2000);
</script>


</body>
</html>





00000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000


const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const path = require('path');
require('dotenv').config();

const { connectDB } = require('./connect');
const User = require('./Models/users');
const Conversation = require('./Models/conversation');

const staticRouter = require('./Routes/staticRouter');
const chatRouter = require('./Routes/chatRouter');

const app = express();
const server = http.createServer(app);
const io = new Server(server);


const passport = require('passport');
require('./config/passport'); // make sure path is correct
app.use(session({
    secret: process.env.SESSION_SECRET || 'your-session-secret',
    resave: false,
    saveUninitialized: false,
    cookie: { secure: false } // true if HTTPS
}));

// Initialize Passport (MUST follow session)
app.use(passport.initialize());
app.use(passport.session());
const authRoutes = require('./Routes/auth'); // <== new Google auth route
// only if using sessions

app.use('/auth', authRoutes); // <== mount it


// EJS setup
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Middleware
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(cookieParser());


app.use(session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
        maxAge: 1000 * 60 * 60 * 5, // ‚úÖ 5 hours
        httpOnly: true,
        sameSite: 'Lax',
        secure: false // set to true if using HTTPS
    }
}));

// Initialize Passport (MUST come after session)
app.use(passport.initialize());
app.use(passport.session());



app.use('/public', express.static(path.join(__dirname, 'public')));
app.use('/uploads', express.static(path.join(__dirname, 'public/uploads')));
app.use('/posts', express.static(path.join(__dirname, 'public/posts')));

// Connect to MongoDB
connectDB(process.env.MONGO_URI);

// Routes
app.use('/', staticRouter);
app.use('/chat', chatRouter);

// ---- ‚úÖ SOCKET.IO LOGIC ----
io.on('connection', (socket) => {
    console.log('New client connected:', socket.id);

    // Join room for conversation
    socket.on('joinRoom', ({ conversationId, userId, friendId }) => {
        if (!conversationId) return;
        socket.join(conversationId);
        console.log(`Socket ${socket.id} joined room ${conversationId}`);
    });

    // Handle sending message
    socket.on('chatMessage', async ({ conversationId, senderId, text }) => {
        if (!conversationId || !senderId || !text) return;

        try {
            const conversation = await Conversation.findById(conversationId);
            if (!conversation) return;

            const message = {
                sender: senderId,
                text,
                timestamp: new Date(),
                readBy: [senderId] // ‚úÖ Mark as read by sender
            };

            conversation.messages.push(message);
            await conversation.save();

            // Send to all in room
            io.to(conversationId).emit('newMessage', {
                conversationId,
                senderId,
                text,
                timestamp: message.timestamp
            });
        } catch (error) {
            console.error('Error saving message:', error);
        }
    });

    // ‚úÖ Handle marking messages as read
    socket.on('markAsRead', async ({ conversationId, userId }) => {
        try {
            const conversation = await Conversation.findById(conversationId);
            if (!conversation) return;

            conversation.messages.forEach(msg => {
                if (!msg.readBy.includes(userId)) {
                    msg.readBy.push(userId);
                }
            });

            await conversation.save();
        } catch (err) {
            console.error('Error marking as read:', err);
        }
    });

    socket.on('disconnect', () => {
        console.log('Client disconnected:', socket.id);
    });
});

// Start server
const PORT = process.env.PORT || 8005;
server.listen(PORT, () => console.log(`Server running on port ${PORT}...`));





00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000









const express = require('express');
const router = express.Router();
const upload = require('../MiddleWares/uploads');
const { authenticate } = require('../MiddleWares/authMiddleware');
const User = require('../Models/users');

// Controller Imports
const {
    signup,
    login,
    logout,
    home,
    searchUsers,
    addFriend,
    viewProfile,
    uploadPost,
    updateProfile,
    viewFriendProfile,
    deletePost,
    removeFriend,
    fetchContacts
} = require('../Controllers/users');

// ------------------- PUBLIC ROUTES -------------------

// Welcome Page
router.get('/', (req, res) => res.render('welcome', { title: 'Welcome' }));

// Signup
router.get('/signup', (req, res) => res.render('signup', { title: 'Signup' }));
router.post('/signup', signup);

// Login
router.get('/login', (req, res) => res.render('login', { title: 'Login' }));
router.post('/login', login);

// ------------------- PROTECTED ROUTES -------------------

router.get('/logout', authenticate, logout);

// Home
router.get('/home', authenticate, home);

// Profile
router.get('/profile', authenticate, viewProfile);
router.post('/profile', authenticate, upload.single('avatar'), updateProfile);
router.post('/profile/upload-post', authenticate, upload.single('photo'), uploadPost);
router.post('/profile/delete-post/:postPath', authenticate, deletePost);
router.get('/api/contacts', authenticate, fetchContacts);

// View Another User's Profile
router.get('/user/:id', authenticate, viewFriendProfile);

// Friend Actions
router.get('/search', authenticate, searchUsers);
router.post('/add-friend/:id', authenticate, addFriend);
router.post('/accept-request/:id', authenticate, async (req, res) => {
    const currentUser = await User.findById(req.user._id);
    const requestSender = await User.findById(req.params.id);

    if (!requestSender) return res.status(404).send('User not found');

    if (!currentUser.friends.includes(requestSender._id)) {
        currentUser.friends.push(requestSender._id);
        requestSender.friends.push(currentUser._id);
    }

    currentUser.requests = currentUser.requests.filter(id => !id.equals(requestSender._id));

    await currentUser.save();
    await requestSender.save();

    res.redirect('/home');
});

router.post('/reject-request/:id', authenticate, async (req, res) => {
    const currentUser = await User.findById(req.user._id);
    currentUser.requests = currentUser.requests.filter(id => !id.equals(req.params.id));
    await currentUser.save();
    res.redirect('/home');
});

router.post('/friends/remove/:id', authenticate, removeFriend);

// ------------------- ADMIN ROUTES -------------------

router.get('/admin', authenticate, async (req, res) => {
    const adminEmail = 'kunchepugokulu12@gmail.com';
    const user = await User.findById(req.user._id);

    if (user.email !== adminEmail) {
        return res.status(403).send('Access Denied');
    }

    try {
        const users = await User.find({ _id: { $ne: user._id } }).populate('friends');
        res.render('auth', {
            title: 'Admin Dashboard',
            admin: user,
            users
        });
    } catch (err) {
        console.error('Error loading admin dashboard:', err);
        res.status(500).send('Server Error');
    }
});

const fs = require('fs');
const path = require('path');

router.post('/admin/delete/:id', authenticate, async (req, res) => {
    const adminEmail = 'kunchepugokulu12@gmail.com';
    const user = await User.findById(req.user._id);

    if (user.email !== adminEmail) {
        return res.status(403).send('Access Denied');
    }

    try {
        // Step 1: Find user to delete
        const userToDelete = await User.findById(req.params.id);
        if (!userToDelete) {
            return res.status(404).send('User not found');
        }

        // Step 2: Construct folder path (based on username)
        const userPostsFolder = path.join(__dirname, '../public/posts', userToDelete.username);

        // Step 3: Delete user's post folder if exists
        if (fs.existsSync(userPostsFolder)) {
            fs.rmSync(userPostsFolder, { recursive: true, force: true });
            console.log(`‚úÖ Deleted folder: ${userPostsFolder}`);
        }

        // Step 4: Delete user
        await User.findByIdAndDelete(req.params.id);

        res.redirect('/admin');
    } catch (error) {
        console.error('‚ùå Error deleting user:', error);
        res.status(500).send('Failed to delete user and their folder');
    }
});




module.exports = router;


00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000



const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

// models/users.js
const userSchema = new mongoose.Schema({
    username: { type: String, unique: true, required: true },
    email: { type: String, unique: true, required: true }, // email should be uniqueString,
    password: { type: String, required: true },
    bio: String,
    about: String,
    avatar: String,
    requests: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    friends: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    posts: [String], // array of image URLs
    online: { type: Boolean, default: false },
    isAdmin: { type: Boolean, default: false }

}, { timestamps: true });


userSchema.pre('save', async function (next) {
    if (this.isModified('password')) {
        this.password = await bcrypt.hash(this.password, 12);
    }
    next();
});

module.exports = mongoose.model('User', userSchema);




00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


const mongoose = require('mongoose');

const conversationSchema = new mongoose.Schema({
    members: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    messages: [{
        sender: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
        text: String,
        timestamp: { type: Date, default: Date.now }
        , readBy: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }]
    }]
}, { timestamps: true });

module.exports = mongoose.model('Conversation', conversationSchema);



00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


const User = require('../Models/users');
const bcrypt = require('bcryptjs');
const { generateToken } = require('../Services/authService');
async function signup(req, res) {
    const { username, email, password } = req.body;

    try {
        const exists = await User.findOne({ email });
        if (exists) return res.status(400).send('User already exists');


        const user = await User.create({ username, email, password });

        const token = generateToken(user._id);
        res.cookie('jwt', token, {
            httpOnly: true,
            sameSite: 'Lax',
            maxAge: 1000 * 60 * 60 * 5 // ‚úÖ 5 hours
        }); // optional for better cookie support
        res.redirect('/profile');
    } catch (err) {
        console.error('Signup error:', err);
        res.status(500).send('Internal Server Error');
    }
}

async function login(req, res) {
    const { email, password } = req.body;

    try {
        const user = await User.findOne({ email });
        if (!user) {
            return res.render('login', { title: 'Login', error: 'User not found' }); // üîß FIXED: should render login
        }

        const match = await bcrypt.compare(password, user.password);
        if (!match) {
            return res.render('login', { title: 'Login', error: 'Wrong password' });
        }

        const token = generateToken(user._id);
        res.cookie('jwt', token, {
            httpOnly: true,
            sameSite: 'Lax',
            maxAge: 1000 * 60 * 60 * 5 // ‚úÖ 5 hours
        });
        // optional but improves compatibility

        if (user.email === 'kunchepugokulu12@gmail.com') {
            return res.redirect('/admin');
        }

        res.redirect('/home');
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).send('Internal Server Error');
    }
}




function logout(req, res) {
    res.clearCookie('jwt');
    res.render('login', { title: 'Login' });
}

const Conversation = require('../Models/conversation'); // Add this if missing at the top



async function home(req, res) {
    try {
        const user = await User.findById(req.user._id)
            .populate('friends', 'username avatar')
            .populate('requests', 'username avatar');

        let conversationId = null;

        if (user.friends.length > 0) {
            const firstFriendId = user.friends[0]._id;
            let conversation = await Conversation.findOne({
                members: { $all: [req.user._id, firstFriendId] },
            });

            if (!conversation) {
                conversation = await Conversation.create({
                    members: [req.user._id, firstFriendId],
                    messages: [],
                });
            }

            conversationId = conversation._id.toString();
        }

        const conversations = await Conversation.find({ members: req.user._id });

        const unreadCounts = {};
        const contactMap = new Map();

        // Map each friendId => latestMessageTime + unreadCount
        for (const conv of conversations) {
            if (!conv || !Array.isArray(conv.members)) continue;

            const otherId = conv.members.find(id =>
                id && id.toString() !== req.user._id.toString()
            );
            if (!otherId) continue;

            const friend = user.friends.find(f => f._id.toString() === otherId.toString());
            if (!friend) continue;

            const count = conv.messages.filter(
                msg =>
                    msg.sender &&
                    msg.sender.toString() !== req.user._id.toString() &&
                    Array.isArray(msg.readBy) &&
                    !msg.readBy.some(u => u.toString() === req.user._id.toString())
            ).length;

            const lastMessage = conv.messages[conv.messages.length - 1];
            const lastMessageTime = lastMessage ? new Date(lastMessage.timestamp || lastMessage.createdAt || 0) : new Date(0);

            contactMap.set(friend._id.toString(), {
                friend,
                unreadCount: count,
                lastMessageTime
            });

            if (count > 0) unreadCounts[friend._id.toString()] = count;
        }

        // For friends without conversation
        user.friends.forEach(f => {
            if (!contactMap.has(f._id.toString())) {
                contactMap.set(f._id.toString(), {
                    friend: f,
                    unreadCount: 0,
                    lastMessageTime: new Date(0)
                });
            }
        });

        // Convert to sorted array
        const allContacts = Array.from(contactMap.values()).sort((a, b) =>
            b.lastMessageTime - a.lastMessageTime
        );

        const newMsgContacts = allContacts.filter(c => c.unreadCount > 0).map(c => c.friend);
        const normalContacts = allContacts.filter(c => c.unreadCount === 0).map(c => c.friend);

        res.render('home', {
            title: 'Your Contacts',
            user,
            contacts: user.friends,
            requests: user.requests || [],
            conversationId,
            unreadCounts,
            newMsgContacts,
            normalContacts
        });

    } catch (error) {
        console.error('Error loading home:', error);
        res.status(500).send('Server Error');
    }
}



const searchUsers = async (req, res) => {
    const query = req.query.q || '';
    const currentUser = await User.findById(req.user._id).populate('friends');

    let users = [];

    if (query.trim() !== '') {
        users = await User.find({
            $or: [
                { username: { $regex: query, $options: 'i' } },
                { email: { $regex: query, $options: 'i' } }
            ],
            _id: { $ne: currentUser._id }
        }).lean(); // ‚úÖ Use lean() to simplify object structure

        // ‚úÖ Fetch all requests in one query to reduce DB load
        const requestSentUsers = await User.find({
            requests: currentUser._id
        }, '_id');

        const requestedIds = new Set(requestSentUsers.map(u => u._id.toString()));

        users = users.map(user => ({
            ...user,
            isFriend: currentUser.friends.some(f => f._id.equals(user._id)),
            requested: requestedIds.has(user._id.toString())
        }));
    }

    if (req.headers['x-requested-with'] === 'XMLHttpRequest') {
        return res.render('partials/userList', { users });
    }

    res.render('search', { title: 'Search Users', users });
};





async function addFriend(req, res) {
    try {
        const currentUser = await User.findById(req.user._id);
        const targetUser = await User.findById(req.params.id);

        if (!targetUser) return res.status(404).send('User not found');

        // Add request if not already requested or friend
        if (
            !targetUser.requests.includes(currentUser._id) &&
            !targetUser.friends.includes(currentUser._id)
        ) {
            targetUser.requests.push(currentUser._id);
            await targetUser.save();
        }

        if (req.headers['x-requested-with'] === 'XMLHttpRequest') {
            return res.status(200).json({ status: 'requested' });
        }

        res.redirect('/home');
    } catch (error) {
        console.error('Error sending friend request:', error);
        res.status(500).send('Server Error');
    }
}



async function viewProfile(req, res) {
    try {
        const user = await User.findById(req.user._id).populate('friends');
        console.log('User posts:', user.posts);
        res.render('profile', { title: 'Your Profile', user });
    } catch (error) {
        console.error('Error loading profile:', error);
        res.status(500).send('Server Error');
    }
}

// async function uploadPost(req, res) {
//     try {
//         const user = await User.findById(req.user._id);
//         if (req.file) {
//             const postPath = '/posts/' + req.file.filename;
//             if (!user.posts.includes(postPath)) {
//                 user.posts.push(postPath);
//                 await user.save();
//             }
//         }
//         res.redirect('/profile');
//     } catch (error) {
//         console.error('Error uploading post:', error);
//         res.status(500).send('Upload failed');
//     }
// }

async function uploadPost(req, res) {
    try {
        const user = await User.findById(req.user._id);

        const imagePath = `/posts/${req.user.username}/${req.file.filename}`;
        user.posts.unshift(imagePath);  // Add at beginning
        await user.save();
        res.redirect('/profile');
    } catch (err) {
        console.error('Upload post error:', err);
        res.status(500).send('Failed to upload post');
    }
};






async function updateProfile(req, res) {
    try {
        const { username, bio, about } = req.body;
        const update = { bio, about };

        const currentUser = await User.findById(req.user._id);
        const oldUsername = currentUser.username;

        if (username && username !== oldUsername) {
            const existingUser = await User.findOne({
                username: { $regex: new RegExp(`^${username}$`, 'i') },
                _id: { $ne: req.user._id }
            });

            if (existingUser) {
                // Suggest alternatives
                const suggestions = [];
                for (let i = 0; suggestions.length < 3 && i < 50; i++) {
                    const suggestion = `${username}${Math.floor(Math.random() * 10000)}`;
                    const exists = await User.findOne({ username: suggestion });
                    if (!exists && !suggestions.includes(suggestion)) {
                        suggestions.push(suggestion);
                    }
                }

                return res.render('username', {
                    title: 'Your Profile',
                    error: 'Username already taken',
                    suggestions
                });
            }

            update.username = username;

            // Move old post folder to new one
            const oldDir = path.join(__dirname, '..', 'public', 'posts', oldUsername);
            const newDir = path.join(__dirname, '..', 'public', 'posts', username);

            if (fs.existsSync(oldDir)) {
                fs.renameSync(oldDir, newDir);

                // Update all post paths in the DB
                currentUser.posts = currentUser.posts.map(post =>
                    post.replace(`/posts/${oldUsername}/`, `/posts/${username}/`)
                );
                update.posts = currentUser.posts;
            }
        }

        if (req.file) {
            update.avatar = `/uploads/${req.file.filename}`;
        }

        await User.findByIdAndUpdate(req.user._id, update);
        res.redirect('/profile');
    } catch (error) {
        console.error('Error updating profile:', error);
        res.status(500).send('Server Error');
    }
}



async function viewFriendProfile(req, res) {
    try {
        const currentUser = await User.findById(req.user._id).populate('friends');
        const friend = await User.findById(req.params.id).populate('friends');

        if (!friend) return res.status(404).send('User not found');

        // Number of friends friend has
        const friendCount = friend.friends.length;

        // Find mutual friends (IDs)
        const currentUserFriendIds = new Set(currentUser.friends.map(f => f._id.toString()));
        const mutualFriends = friend.friends.filter(f => currentUserFriendIds.has(f._id.toString()));

        const mutualCount = mutualFriends.length;

        res.render('friend-profile', {
            title: `${friend.username}'s Profile`,
            friend,
            friendCount,
            mutualFriends,
            mutualCount,
        });
    } catch (err) {
        console.error('Error loading friend profile:', err);
        res.status(500).send('Server Error');
    }
}


async function removeFriend(req, res) {
    try {
        const userId = req.user._id;
        const friendId = req.params.id;

        const user = await User.findById(userId);
        const friend = await User.findById(friendId);

        if (!user || !friend) {
            return res.status(404).send('User not found');
        }

        // Remove friend from both users
        user.friends = user.friends.filter(f => f.toString() !== friendId);
        friend.friends = friend.friends.filter(f => f.toString() !== userId);

        await user.save();
        await friend.save();

        res.redirect('/profile');
    } catch (error) {
        console.error('Error removing friend:', error);
        res.status(500).send('Server error');
    }
};



const fs = require('fs');
const path = require('path');

async function deletePost(req, res) {
    try {
        const user = await User.findById(req.user._id);
        const postToDelete = decodeURIComponent(req.params.postPath); // Ex: '1750486752107-image.jpg'

        // 1. Remove post path from user's post array
        user.posts = user.posts.filter(post => !post.includes(postToDelete));
        await user.save();

        // 2. Construct full path to the image file
        const filePath = path.join(__dirname, '../public/posts', postToDelete);

        // 3. Delete the file if it exists
        fs.unlink(filePath, (err) => {
            if (err) {
                console.error('‚ùå Error deleting file from public/posts:', err.message);
            } else {
                console.log('‚úÖ Deleted file from disk:', filePath);
            }
        });

        // 4. Redirect back to profile
        res.redirect('/profile');
    } catch (error) {
        console.error('Error deleting post:', error);
        res.status(500).send('Delete failed');
    }
}

module.exports = { deletePost };




async function fetchContacts(req, res) {
    try {
        const user = await User.findById(req.user._id)
            .populate('friends', 'username avatar');

        const conversations = await Conversation.find({ members: req.user._id });

        const contactMap = new Map();
        const unreadCounts = {};

        for (const conv of conversations) {
            const otherId = conv.members.find(id => id && id.toString() !== req.user._id.toString());

            if (!otherId) continue;

            const friend = user.friends.find(f => f._id.toString() === otherId.toString());
            if (!friend) continue;

            const count = conv.messages.filter(
                msg =>
                    msg.sender?.toString() !== req.user._id.toString() &&
                    !msg.readBy?.some(r => r.toString() === req.user._id.toString())
            ).length;

            const lastMessage = conv.messages[conv.messages.length - 1];
            const lastMessageTime = lastMessage ? new Date(lastMessage.timestamp || lastMessage.createdAt || 0) : new Date(0);

            contactMap.set(friend._id.toString(), {
                friend,
                unreadCount: count,
                lastMessageTime
            });

            if (count > 0) unreadCounts[friend._id.toString()] = count;
        }

        user.friends.forEach(f => {
            if (!contactMap.has(f._id.toString())) {
                contactMap.set(f._id.toString(), {
                    friend: f,
                    unreadCount: 0,
                    lastMessageTime: new Date(0)
                });
            }
        });

        const allContacts = Array.from(contactMap.values()).sort((a, b) => b.lastMessageTime - a.lastMessageTime);

        res.json({
            success: true,
            contacts: allContacts.map(c => ({
                _id: c.friend._id,
                username: c.friend.username,
                avatar: c.friend.avatar,
                unreadCount: c.unreadCount
            }))
        });
    } catch (error) {
        console.error('Fetch contacts error:', error);
        res.status(500).json({ success: false, message: 'Server error' });
    }
}


module.exports = {
    signup,
    login,
    logout,
    home,
    searchUsers,
    addFriend,
    viewProfile,
    uploadPost,
    updateProfile,
    viewFriendProfile,
    deletePost,
    removeFriend,
    fetchContacts
};






00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000



const express = require('express');
const router = express.Router();
const Conversation = require('../Models/conversation');
const { authenticate } = require('../MiddleWares/authMiddleware');

// Get conversation between logged-in user and a friend
router.get('/conversation/:friendId', authenticate, async (req, res) => {
    const userId = req.user._id.toString();
    const friendId = req.params.friendId;

    try {
        let conversation = await Conversation.findOne({
            members: { $all: [userId, friendId] }
        }).populate('messages.sender', 'username avatar');

        if (!conversation) {
            conversation = new Conversation({
                members: [userId, friendId],
                messages: []
            });
            await conversation.save();
        }

        res.json(conversation);
    } catch (err) {
        console.error('Error fetching conversation:', err);
        res.status(500).json({ error: 'Server error' });
    }
});

module.exports = router;



00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000





const express = require('express');
const router = express.Router();
const Conversation = require('../Models/conversation');
const { authenticate } = require('../MiddleWares/authMiddleware');

// Get conversation between logged-in user and a friend
router.get('/conversation/:friendId', authenticate, async (req, res) => {
    const userId = req.user._id.toString();
    const friendId = req.params.friendId;

    try {
        let conversation = await Conversation.findOne({
            members: { $all: [userId, friendId] }
        }).populate('messages.sender', 'username avatar');

        if (!conversation) {
            conversation = new Conversation({
                members: [userId, friendId],
                messages: []
            });
            await conversation.save();
        }

        res.json(conversation);
    } catch (err) {
        console.error('Error fetching conversation:', err);
        res.status(500).json({ error: 'Server error' });
    }
});

module.exports = router;



000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000
